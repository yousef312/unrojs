{"version":3,"file":"unro.esm.js","sources":["../src/unro.js"],"sourcesContent":["const algos = ['clearpath', 'insertion', 'lineare'];\r\n\r\n/**\r\n * Stack states bank\r\n * @type {Map<Stack,{state: *,id: number}>}\r\n */\r\nconst Bank = new Map();\r\nlet counter = 0;\r\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\r\nArray.prototype.insert = function (elm, index) {\r\n    this.splice(clamp(index, 0, this.length), 0, elm);\r\n    return index;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Stack\r\n * @property {function} undo called when user is attempting to undo action\r\n * @property {function} redo called when user is attempting to redo action\r\n */\r\n\r\n/**\r\n * Simple integration of undo/redo functionalities\r\n * @author Yousef Neji\r\n */\r\nfunction Unro(max, algo) {\r\n    /**\r\n     * The stacks container\r\n     * @type {Array<Stack>}\r\n     */\r\n    this.stack = [];\r\n\r\n    /**\r\n     * Current stack/state index \r\n     * @type {number} \r\n     */\r\n    this.current = -1;\r\n\r\n    /**\r\n     * Maximum number of stacks that can be held.\r\n     * @type {number}\r\n     */\r\n    this.maximum = typeof max === \"number\" ? max : 100;\r\n\r\n    /**\r\n     * The algorithme to use when stacking, or the stacking method, may be one of those:\r\n     *  - `clearpath` : once you undo and push new stack the forward stacks will be removed.\r\n     *  - `insertion` : once you undo and push new stack the new one will be inserted in front of the forward stacks.\r\n     *  - `lineare` : once you push new stack it will be always added to the end of the stacks list.\r\n     * \r\n     * by defaults its `clearpath`\r\n     * @type {string}\r\n     */\r\n    this.algo = algos.includes(algo) ? algo : \"clearpath\";\r\n}\r\nUnro.prototype = {\r\n    /**\r\n     * Push new stack/state into the stacks list, and directly execute unless\r\n     * you set `dontExecute` as true.\r\n     * @method Unro#push\r\n     * @param {Stack} stack\r\n     * @param {boolean} dontExecute\r\n     * @returns {number} the current state index\r\n     */\r\n    push: function (stack, dontExecute) {\r\n        if (!stack || typeof stack.undo != \"function\" || typeof stack.redo != \"function\")\r\n            return console.error(`[UnroJS] wrong stack defintion in .push, a stack must have undo & redo functins`);\r\n\r\n        // let's prepare the stack state storage\r\n        Bank.set(stack, { state: null, id: ++counter });\r\n        let oldIndex = this.current;\r\n\r\n        if (this.algo === 'lineare')\r\n            this.current = this.stack.push(elm) - 1;\r\n        else if (this.algo === 'clearpath') {\r\n            if (this.stack[oldIndex + 1] !== undefined)\r\n                this.stack.splice(oldIndex + 1, this.stack.length)\r\n                .forEach(old => Bank.delete(old));\r\n            this.current = this.stack.push(elm) - 1;\r\n        } else if (this.algo === 'insertion') {\r\n            this.current = this.stack.insert(elm, oldIndex + 1);\r\n        }\r\n\r\n        // respect maximum term\r\n        if (this.stack.length > this.maximum) {\r\n            this.stack.shift();\r\n            this.current = oldIndex;\r\n        } else if (dontExecute === true) {\r\n            this.current--;\r\n            this.redo();\r\n        }\r\n\r\n        return this.current;\r\n    },\r\n    /**\r\n     * Undo the last change or state/stack\r\n     * @method Unro#undo\r\n     * @returns {Unro}\r\n     */\r\n    undo: function () {\r\n        if (!this.stack[this.current - 1]) return;\r\n        this.current--;\r\n        this.stack[this.current].undo.call(this);\r\n        return this;\r\n    },\r\n    /**\r\n     * Redo the last change or state/stack\r\n     * @method Unro#redo\r\n     * @returns {Unro}\r\n     */\r\n    redo: function () {\r\n        if (!this.stack[this.current + 1]) return;\r\n        this.current++;\r\n        this.stack[this.current].redo.call(this);\r\n        return this;\r\n    },\r\n    /**\r\n     * Expand the stack maximum length\r\n     * @method Unro#expand\r\n     * @param {number} value\r\n     * @returns {Unro}\r\n     */\r\n    expand: function (value) {\r\n        this.maximum = typeof value == \"number\" ? value : this.maximum;\r\n        return this\r\n    },\r\n    /**\r\n     * Clear/reset the stack content\r\n     * @method Unro#freeUp\r\n     * @returns {Unro}\r\n     */\r\n    freeUp: function () {\r\n        this.stack = [];\r\n        Bank.clear();\r\n        this.current = 0;\r\n        return this\r\n    },\r\n    /**\r\n     * Move to a specified stack, the function will execute all stack up to \r\n     * the one requested, and return either the stack or:\r\n     *  - `out-of-range`: when requested stack index doesn't exists\r\n     *  - `current`: if requested stack is the current one\r\n     * @method Unro#moveTo\r\n     * @param {number} i \r\n     * @returns {string} the wanted stack content or the string `out-of-rang`\r\n     */\r\n    moveTo: function (i) {\r\n        if (i === this.current) return 'current';\r\n        if (this.stack[i]) {\r\n            // you can't just jump from age 20 to 55\r\n            // you must go through all between\r\n            // the same happens here\r\n            if (i > this.current)\r\n                for (let j = this.current + 1; j <= i; j++) {\r\n                    this.current = j; // required for state functionality\r\n                    this.stack[j].redo.call(this); // redoing the stack\r\n                }\r\n            else\r\n                for (let j = this.current; j >= i; j--) {\r\n                    this.current = j; // required for state functionality\r\n                    this.stack[j].undo.call(this); // undoing the stack\r\n                }\r\n\r\n            this.current = i;\r\n            return this.stack[i];\r\n        } else return 'out-of-range';\r\n    },\r\n    /**\r\n     * Change the `algo` property value, available options are:\r\n     *  - `clearpath` : once you undo and push new stack the forward stacks will be removed.\r\n     *  - `insertion` : once you undo and push new stack the new one will be inserted in front of the forward stacks.\r\n     *  - `lineare` : once you push new stack it will be always added to the end of the stacks list.\r\n     * @method Unro#setAlgorithme\r\n     * @param {string} algo \r\n     * @returns {boolean}\r\n     */\r\n    setAlgorithme: function (algo) {\r\n        if (algos.includes(algo)) {\r\n            this.algo = algo;\r\n            return true\r\n        }\r\n        return false\r\n    },\r\n    /**\r\n     * Save to stack state, better be used inside `.undo` or `.redo` functions\r\n     * @method Unro#save\r\n     * @param {*} data\r\n     */\r\n    save: function (data) {\r\n        Bank.get(this.stack[this.current]).state = data;\r\n    },\r\n    /**\r\n     * Load data from stack state.\r\n     * @method Unro#load\r\n     * @returns {*}\r\n     */\r\n    load: function () {\r\n        return Bank.get(this.stack[this.current]).state;\r\n    }\r\n}\r\n\r\nwindow.Unro = Unro;\r\nexport default Unro;"],"names":[],"mappings":"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"}