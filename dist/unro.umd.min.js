!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).unro=e()}(this,function(){"use strict";const t=["clearpath","insertion","lineare"];function e(e,i){this.stack=[],this.current=-1,this.maximum="number"==typeof e?e:20,this.algo=t.includes(i)?i:"clearpath"}return e.prototype={push:function(t){return t&&"function"==typeof t.undo&&"function"==typeof t.redo?("lineare"===this.algo?this.current=this.stack.push(elm)-1:"clearpath"===this.algo?(void 0!==this.stack[this.current+1]&&this.stack.splice(this.current+1,this.stack.length),this.current=this.stack.push(elm)-1):"insertion"===this.algo&&this.stack.insert(elm,this.current+1),this.stack.length>this.maximum&&this.stack.shift(),this.current):console.error("[UnroJS] wrong stack defintion in .push, a stack must have undo & redo functins")},undo:function(t=1){return this.current=Math.max(this.current-t,0),this.stack[this.current].undo(),this},redo:function(t=1){return this.current=Math.min(this.current+t,this.stack.length-1),this.stack[this.current].redo(),this},expand:function(t){return this.maximum="number"==typeof t?t:this.maximum,this},freeUp:function(){return this.stack=[],this.current=0,this},moveTo:function(t){if(t===this.current)return"current";if(this.stack[t]){if(t>this.current)for(let e=this.current+1;e<=t;e++)this.stack[e].redo();else for(let e=this.current;e>=t;e--)this.stack[e].undo();return this.current=t,this.stack[t]}return"out-of-range"},setAlgorithme:function(e){return!!t.includes(e)&&(this.algo=e,!0)}},window.Unro=e,e});
//# sourceMappingURL=unro.umd.min.js.map
