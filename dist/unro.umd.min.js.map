{"version":3,"file":"unro.umd.min.js","sources":["../src/unro.js"],"sourcesContent":["const algos = ['clearpath', 'insertion', 'lineare'];\r\n\r\n/**\r\n * @typedef {Object} Stack\r\n * @property {function} undo called when user is attempting to undo action\r\n * @property {function} redo called when user is attempting to redo action\r\n */\r\n\r\n/**\r\n * Simple integration of undo/redo functionalities\r\n * @author Yousef Neji\r\n */\r\nfunction Unro(max, algo) {\r\n    /**\r\n     * The stacks container\r\n     * @type {Array<Stack>}\r\n     */\r\n    this.stack = [];\r\n\r\n    /**\r\n     * Current stack/state index \r\n     * @type {number} \r\n     */\r\n    this.current = -1;\r\n\r\n    /**\r\n     * Maximum number of stacks that can be held.\r\n     * @type {number}\r\n     */\r\n    this.maximum = typeof max === \"number\" ? max : 20;\r\n\r\n    /**\r\n     * The algorithme to use when stacking, or the stacking method, may be one of those:\r\n     *  - `clearpath` : once you undo and push new stack the forward stacks will be removed.\r\n     *  - `insertion` : once you undo and push new stack the new one will be inserted in front of the forward stacks.\r\n     *  - `lineare` : once you push new stack it will be always added to the end of the stacks list.\r\n     * \r\n     * by defaults its `clearpath`\r\n     * @type {string}\r\n     */\r\n    this.algo = algos.includes(algo) ? algo : \"clearpath\";\r\n}\r\nUnro.prototype = {\r\n    /**\r\n     * Push new stack/state into the stacks list\r\n     * @method Unro#push\r\n     * @param {Stack} stack\r\n     * @returns {number} the current state index\r\n     */\r\n    push: function (stack) {\r\n        if (!stack || typeof stack.undo != \"function\" || typeof stack.redo != \"function\")\r\n            return console.error(`[UnroJS] wrong stack defintion in .push, a stack must have undo & redo functins`);\r\n\r\n        if (this.algo === 'lineare') {\r\n            this.current = this.stack.push(elm) - 1;\r\n        }\r\n        else if (this.algo === 'clearpath') {\r\n            if (this.stack[this.current + 1] !== undefined) {\r\n                this.stack.splice(this.current + 1, this.stack.length);\r\n            }\r\n            this.current = this.stack.push(elm) - 1;\r\n        }\r\n        else if (this.algo === 'insertion') {\r\n            this.stack.insert(elm, this.current + 1);\r\n        }\r\n\r\n        // respect maximum term\r\n        if (this.stack.length > this.maximum) {\r\n            this.stack.shift();\r\n        }\r\n\r\n        return this.current;\r\n    },\r\n    /**\r\n     * Undo the last change or state/stack\r\n     * @method Unro#undo\r\n     * @param {number} step how much steps to undo; default to 1\r\n     * @returns {Unro}\r\n     */\r\n    undo: function (step = 1) {\r\n        this.current = Math.max(this.current - step, 0);\r\n        this.stack[this.current].undo();\r\n        return this;\r\n    },\r\n    /**\r\n     * Redo the last change or state/stack\r\n     * @method Unro#redo\r\n     * @param {number} step how much states to redo; default to 1\r\n     * @returns {Unro}\r\n     */\r\n    redo: function (step = 1) {\r\n        this.current = Math.min(this.current + step,this.stack.length - 1);\r\n        this.stack[this.current].redo();\r\n        return this;\r\n    },\r\n    /**\r\n     * Expand the stack maximum length\r\n     * @method Unro#expand\r\n     * @param {number} value\r\n     * @returns {Unro}\r\n     */\r\n    expand: function (value) {\r\n        this.maximum = typeof value == \"number\" ? value : this.maximum;\r\n        return this\r\n    },\r\n    /**\r\n     * Clear/reset the stack content\r\n     * @method Unro#freeUp\r\n     * @returns {Unro}\r\n     */\r\n    freeUp: function () {\r\n        this.stack = [];\r\n        this.current = 0;\r\n        return this\r\n    },\r\n    /**\r\n     * Move to a specified stack, the function will execute all stack up to \r\n     * the one requested, and return either the stack or:\r\n     *  - `out-of-range`: when requested stack index doesn't exists\r\n     *  - `current`: if requested stack is the current one\r\n     * @method Unro#moveTo\r\n     * @param {number} i \r\n     * @returns {string} the wanted stack content or the string `out-of-rang`\r\n     */\r\n    moveTo: function (i) {\r\n        if (i === this.current) return 'current';\r\n        if (this.stack[i]) {\r\n            // you can't just jump from age 20 to 55\r\n            // you must go through all between\r\n            // the same happens here\r\n            if (i > this.current)\r\n                for (let j = this.current + 1; j <= i; j++)\r\n                    this.stack[j].redo(); // redoing the stack\r\n            else\r\n                for (let j = this.current; j >= i; j--)\r\n                    this.stack[j].undo(); // undoing the stack\r\n\r\n            this.current = i;\r\n            return this.stack[i];\r\n        } else return 'out-of-range';\r\n    },\r\n    /**\r\n     * Change the `algo` property value, available options are:\r\n     *  - `clearpath` : once you undo and push new stack the forward stacks will be removed.\r\n     *  - `insertion` : once you undo and push new stack the new one will be inserted in front of the forward stacks.\r\n     *  - `lineare` : once you push new stack it will be always added to the end of the stacks list.\r\n     * @method Unro#setAlgorithme\r\n     * @param {string} algo \r\n     * @returns {boolean}\r\n     */\r\n    setAlgorithme: function (algo) {\r\n        if (algos.includes(algo)) {\r\n            this.algo = algo;\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n}\r\n\r\nwindow.Unro = Unro;\r\nexport default Unro;"],"names":["algos","Unro","max","algo","this","stack","current","maximum","includes","prototype","push","undo","redo","elm","undefined","splice","length","insert","shift","console","error","step","Math","min","expand","value","freeUp","moveTo","i","j","setAlgorithme","window"],"mappings":"oOAAA,MAAMA,EAAQ,CAAC,YAAa,YAAa,WAYzC,SAASC,EAAKC,EAAKC,GAKfC,KAAKC,MAAQ,GAMbD,KAAKE,WAMLF,KAAKG,QAAyB,iBAARL,EAAmBA,EAAM,GAW/CE,KAAKD,KAAOH,EAAMQ,SAASL,GAAQA,EAAO,WAC9C,QACAF,EAAKQ,UAAY,CAObC,KAAM,SAAUL,GACZ,OAAKA,GAA8B,mBAAdA,EAAMM,MAA2C,mBAAdN,EAAMO,MAG5C,YAAdR,KAAKD,KACLC,KAAKE,QAAUF,KAAKC,MAAMK,KAAKG,KAAO,EAEnB,cAAdT,KAAKD,WAC2BW,IAAjCV,KAAKC,MAAMD,KAAKE,QAAU,IAC1BF,KAAKC,MAAMU,OAAOX,KAAKE,QAAU,EAAGF,KAAKC,MAAMW,QAEnDZ,KAAKE,QAAUF,KAAKC,MAAMK,KAAKG,KAAO,GAEnB,cAAdT,KAAKD,MACVC,KAAKC,MAAMY,OAAOJ,IAAKT,KAAKE,QAAU,GAItCF,KAAKC,MAAMW,OAASZ,KAAKG,SACzBH,KAAKC,MAAMa,QAGRd,KAAKE,SApBDa,QAAQC,MAAM,kFAqB7B,EAOAT,KAAM,SAAUU,EAAO,GAGnB,OAFAjB,KAAKE,QAAUgB,KAAKpB,IAAIE,KAAKE,QAAUe,EAAM,GAC7CjB,KAAKC,MAAMD,KAAKE,SAASK,OAClBP,IACX,EAOAQ,KAAM,SAAUS,EAAO,GAGnB,OAFAjB,KAAKE,QAAUgB,KAAKC,IAAInB,KAAKE,QAAUe,EAAKjB,KAAKC,MAAMW,OAAS,GAChEZ,KAAKC,MAAMD,KAAKE,SAASM,OAClBR,IACX,EAOAoB,OAAQ,SAAUC,GAEd,OADArB,KAAKG,QAA0B,iBAATkB,EAAoBA,EAAQrB,KAAKG,QAChDH,IACX,EAMAsB,OAAQ,WAGJ,OAFAtB,KAAKC,MAAQ,GACbD,KAAKE,QAAU,EACRF,IACX,EAUAuB,OAAQ,SAAUC,GACd,GAAIA,IAAMxB,KAAKE,QAAS,MAAO,UAC/B,GAAIF,KAAKC,MAAMuB,GAAI,CAIf,GAAIA,EAAIxB,KAAKE,QACT,IAAK,IAAIuB,EAAIzB,KAAKE,QAAU,EAAGuB,GAAKD,EAAGC,IACnCzB,KAAKC,MAAMwB,GAAGjB,YAElB,IAAK,IAAIiB,EAAIzB,KAAKE,QAASuB,GAAKD,EAAGC,IAC/BzB,KAAKC,MAAMwB,GAAGlB,OAGtB,OADAP,KAAKE,QAAUsB,EACRxB,KAAKC,MAAMuB,EACtB,CAAO,MAAO,cAClB,EAUAE,cAAe,SAAU3B,GACrB,QAAIH,EAAMQ,SAASL,KACfC,KAAKD,KAAOA,GACL,EAGf,GAGJ4B,OAAO9B,KAAOA"}