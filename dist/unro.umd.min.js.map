{"version":3,"file":"unro.umd.min.js","sources":["../src/unro.js"],"sourcesContent":["const algos = ['clearpath', 'insertion', 'lineare'];\r\n\r\n/**\r\n * Stack states bank\r\n * @type {Map<Stack,{state: *,id: number}>}\r\n */\r\nconst Bank = new Map();\r\nlet counter = 0;\r\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\r\nArray.prototype.insert = function (elm, index) {\r\n    this.splice(clamp(index, 0, this.length), 0, elm);\r\n    return index;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Stack\r\n * @property {function} undo called when user is attempting to undo action\r\n * @property {function} redo called when user is attempting to redo action\r\n */\r\n\r\n/**\r\n * Simple integration of undo/redo functionalities\r\n * @author Yousef Neji\r\n */\r\nfunction Unro(max, algo) {\r\n    /**\r\n     * The stacks container\r\n     * @type {Array<Stack>}\r\n     */\r\n    this.stack = [];\r\n\r\n    /**\r\n     * Current stack/state index \r\n     * @type {number} \r\n     */\r\n    this.current = -1;\r\n\r\n    /**\r\n     * Maximum number of stacks that can be held.\r\n     * @type {number}\r\n     */\r\n    this.maximum = typeof max === \"number\" ? max : 100;\r\n\r\n    /**\r\n     * The algorithme to use when stacking, or the stacking method, may be one of those:\r\n     *  - `clearpath` : once you undo and push new stack the forward stacks will be removed.\r\n     *  - `insertion` : once you undo and push new stack the new one will be inserted in front of the forward stacks.\r\n     *  - `lineare` : once you push new stack it will be always added to the end of the stacks list.\r\n     * \r\n     * by defaults its `clearpath`\r\n     * @type {string}\r\n     */\r\n    this.algo = algos.includes(algo) ? algo : \"clearpath\";\r\n}\r\nUnro.prototype = {\r\n    /**\r\n     * Push new stack/state into the stacks list, and directly execute unless\r\n     * you set `dontExecute` as true.\r\n     * @method Unro#push\r\n     * @param {Stack} stack\r\n     * @param {boolean} dontExecute\r\n     * @returns {number} the current state index\r\n     */\r\n    push: function (stack, dontExecute) {\r\n        if (!stack || typeof stack.undo != \"function\" || typeof stack.redo != \"function\")\r\n            return console.error(`[UnroJS] wrong stack defintion in .push, a stack must have undo & redo functins`);\r\n\r\n        // let's prepare the stack state storage\r\n        Bank.set(stack, { state: null, id: ++counter });\r\n        let oldIndex = this.current;\r\n\r\n        if (this.algo === 'lineare')\r\n            this.current = this.stack.push(elm) - 1;\r\n        else if (this.algo === 'clearpath') {\r\n            if (this.stack[oldIndex + 1] !== undefined)\r\n                this.stack.splice(oldIndex + 1, this.stack.length)\r\n                .forEach(old => Bank.delete(old));\r\n            this.current = this.stack.push(elm) - 1;\r\n        } else if (this.algo === 'insertion') {\r\n            this.current = this.stack.insert(elm, oldIndex + 1);\r\n        }\r\n\r\n        // respect maximum term\r\n        if (this.stack.length > this.maximum) {\r\n            this.stack.shift();\r\n            this.current = oldIndex;\r\n        } else if (dontExecute === true) {\r\n            this.current--;\r\n            this.redo();\r\n        }\r\n\r\n        return this.current;\r\n    },\r\n    /**\r\n     * Undo the last change or state/stack\r\n     * @method Unro#undo\r\n     * @returns {Unro}\r\n     */\r\n    undo: function () {\r\n        if (!this.stack[this.current - 1]) return;\r\n        this.current--;\r\n        this.stack[this.current].undo.call(this);\r\n        return this;\r\n    },\r\n    /**\r\n     * Redo the last change or state/stack\r\n     * @method Unro#redo\r\n     * @returns {Unro}\r\n     */\r\n    redo: function () {\r\n        if (!this.stack[this.current + 1]) return;\r\n        this.current++;\r\n        this.stack[this.current].redo.call(this);\r\n        return this;\r\n    },\r\n    /**\r\n     * Expand the stack maximum length\r\n     * @method Unro#expand\r\n     * @param {number} value\r\n     * @returns {Unro}\r\n     */\r\n    expand: function (value) {\r\n        this.maximum = typeof value == \"number\" ? value : this.maximum;\r\n        return this\r\n    },\r\n    /**\r\n     * Clear/reset the stack content\r\n     * @method Unro#freeUp\r\n     * @returns {Unro}\r\n     */\r\n    freeUp: function () {\r\n        this.stack = [];\r\n        Bank.clear();\r\n        this.current = 0;\r\n        return this\r\n    },\r\n    /**\r\n     * Move to a specified stack, the function will execute all stack up to \r\n     * the one requested, and return either the stack or:\r\n     *  - `out-of-range`: when requested stack index doesn't exists\r\n     *  - `current`: if requested stack is the current one\r\n     * @method Unro#moveTo\r\n     * @param {number} i \r\n     * @returns {string} the wanted stack content or the string `out-of-rang`\r\n     */\r\n    moveTo: function (i) {\r\n        if (i === this.current) return 'current';\r\n        if (this.stack[i]) {\r\n            // you can't just jump from age 20 to 55\r\n            // you must go through all between\r\n            // the same happens here\r\n            if (i > this.current)\r\n                for (let j = this.current + 1; j <= i; j++) {\r\n                    this.current = j; // required for state functionality\r\n                    this.stack[j].redo.call(this); // redoing the stack\r\n                }\r\n            else\r\n                for (let j = this.current; j >= i; j--) {\r\n                    this.current = j; // required for state functionality\r\n                    this.stack[j].undo.call(this); // undoing the stack\r\n                }\r\n\r\n            this.current = i;\r\n            return this.stack[i];\r\n        } else return 'out-of-range';\r\n    },\r\n    /**\r\n     * Change the `algo` property value, available options are:\r\n     *  - `clearpath` : once you undo and push new stack the forward stacks will be removed.\r\n     *  - `insertion` : once you undo and push new stack the new one will be inserted in front of the forward stacks.\r\n     *  - `lineare` : once you push new stack it will be always added to the end of the stacks list.\r\n     * @method Unro#setAlgorithme\r\n     * @param {string} algo \r\n     * @returns {boolean}\r\n     */\r\n    setAlgorithme: function (algo) {\r\n        if (algos.includes(algo)) {\r\n            this.algo = algo;\r\n            return true\r\n        }\r\n        return false\r\n    },\r\n    /**\r\n     * Save to stack state, better be used inside `.undo` or `.redo` functions\r\n     * @method Unro#save\r\n     * @param {*} data\r\n     */\r\n    save: function (data) {\r\n        Bank.get(this.stack[this.current]).state = data;\r\n    },\r\n    /**\r\n     * Load data from stack state.\r\n     * @method Unro#load\r\n     * @returns {*}\r\n     */\r\n    load: function () {\r\n        return Bank.get(this.stack[this.current]).state;\r\n    }\r\n}\r\n\r\nwindow.Unro = Unro;\r\nexport default Unro;"],"names":["algos","Bank","Map","counter","Unro","max","algo","this","stack","current","maximum","includes","Array","prototype","insert","elm","index","v","min","splice","length","push","dontExecute","undo","redo","console","error","set","state","id","oldIndex","undefined","forEach","old","delete","shift","call","expand","value","freeUp","clear","moveTo","i","j","setAlgorithme","save","data","get","load","window"],"mappings":"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"}