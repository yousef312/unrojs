const algos=["clearpath","insertion","lineare"];function Unro(t,r){this.stack=[],this.current=-1,this.maximum="number"==typeof t?t:20,this.algo=algos.includes(r)?r:"clearpath"}Unro.prototype={push:function(t){return t&&"function"==typeof t.undo&&"function"==typeof t.redo?("lineare"===this.algo?this.current=this.stack.push(elm)-1:"clearpath"===this.algo?(void 0!==this.stack[this.current+1]&&this.stack.splice(this.current+1,this.stack.length),this.current=this.stack.push(elm)-1):"insertion"===this.algo&&this.stack.insert(elm,this.current+1),this.stack.length>this.maximum&&this.stack.shift(),this.current):console.error("[UnroJS] wrong stack defintion in .push, a stack must have undo & redo functins")},undo:function(t=1){return this.current=Math.max(this.current-t,0),this.stack[this.current].undo(),this},redo:function(t=1){return this.current=Math.min(this.current+t,this.stack.length-1),this.stack[this.current].redo(),this},expand:function(t){return this.maximum="number"==typeof t?t:this.maximum,this},freeUp:function(){return this.stack=[],this.current=0,this},moveTo:function(t){if(t===this.current)return"current";if(this.stack[t]){if(t>this.current)for(let r=this.current+1;r<=t;r++)this.stack[r].redo();else for(let r=this.current;r>=t;r--)this.stack[r].undo();return this.current=t,this.stack[t]}return"out-of-range"},setAlgorithme:function(t){return!!algos.includes(t)&&(this.algo=t,!0)}},window.Unro=Unro;export default Unro;