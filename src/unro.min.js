const algos=["clearpath","insertion","lineare"],Bank=new Map;let counter=0;const clamp=(t,r,s)=>t<r?r:t>s?s:t;function Unro(t,r){this.stack=[],this.current=-1,this.maximum="number"==typeof t?t:100,this.algo=algos.includes(r)?r:"clearpath"}Array.prototype.insert=function(t,r){var s,n,i;return this.splice((s=r,n=0,i=this.length,s<n?n:s>i?i:s),0,t),r},Unro.prototype={push:function(t,r){if(!t||"function"!=typeof t.undo||"function"!=typeof t.redo)return console.error("[UnroJS] wrong stack defintion in .push, a stack must have undo & redo functins");Bank.set(t,{state:null,id:++counter});let s=this.current;return"lineare"===this.algo?this.current=this.stack.push(elm)-1:"clearpath"===this.algo?(void 0!==this.stack[s+1]&&this.stack.splice(s+1,this.stack.length).forEach((t=>Bank.delete(t))),this.current=this.stack.push(elm)-1):"insertion"===this.algo&&(this.current=this.stack.insert(elm,s+1)),this.stack.length>this.maximum?(this.stack.shift(),this.current=s):!0===r&&(this.current--,this.redo()),this.current},undo:function(){if(this.stack[this.current-1])return this.current--,this.stack[this.current].undo.call(this),this},redo:function(){if(this.stack[this.current+1])return this.current++,this.stack[this.current].redo.call(this),this},expand:function(t){return this.maximum="number"==typeof t?t:this.maximum,this},freeUp:function(){return this.stack=[],Bank.clear(),this.current=0,this},moveTo:function(t){if(t===this.current)return"current";if(this.stack[t]){if(t>this.current)for(let r=this.current+1;r<=t;r++)this.current=r,this.stack[r].redo.call(this);else for(let r=this.current;r>=t;r--)this.current=r,this.stack[r].undo.call(this);return this.current=t,this.stack[t]}return"out-of-range"},setAlgorithme:function(t){return!!algos.includes(t)&&(this.algo=t,!0)},save:function(t){Bank.get(this.stack[this.current]).state=t},load:function(){return Bank.get(this.stack[this.current]).state}},window.Unro=Unro;export default Unro;